package generator

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/alsmola/graphgrc/internal/parser"
)

const (
	backlinkSectionHeader = "## Referenced By"
	backlinkAutoGenNote   = "*This section is automatically generated by `make generate-backlinks`. Do not edit manually.*"
	backlinkSeparator     = "---"
)

// HasBacklinkSection checks if content contains the backlink section
func HasBacklinkSection(content string) bool {
	return strings.Contains(content, backlinkSectionHeader)
}

// UpdateBacklinks updates a single file with its backlinks
// filePath is the absolute filesystem path, repoRelativePath is the path from repo root (e.g., "/custom/acc-01.md")
func UpdateBacklinks(filePath string, repoRelativePath string, repoRoot string, backlinks map[parser.DocumentType][]parser.BacklinkInfo) error {
	// Read the entire file
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read file: %w", err)
	}

	fileContent := string(content)

	// Check if file has the Referenced By section
	if !strings.Contains(fileContent, backlinkSectionHeader) {
		fmt.Fprintf(os.Stderr, "Warning: %s does not contain '%s' section, skipping\n",
			filePath, backlinkSectionHeader)
		return nil
	}

	// Split content at the Referenced By section
	parts := strings.Split(fileContent, backlinkSectionHeader)
	if len(parts) != 2 {
		return fmt.Errorf("expected exactly one '%s' section in file", backlinkSectionHeader)
	}

	// Keep everything before the section header
	beforeSection := parts[0]

	// Generate the new backlinks content
	backlinkContent := generateBacklinkContent(repoRelativePath, repoRoot, backlinks)

	// Combine: original content + section header + new backlinks
	newContent := beforeSection + backlinkSectionHeader + "\n\n" + backlinkContent

	// Write back to file
	err = os.WriteFile(filePath, []byte(newContent), 0644)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// extractTitleFromFile reads a markdown file and extracts the title from YAML frontmatter or H1 heading
func extractTitleFromFile(repoRelativePath string, repoRoot string) string {
	// Convert repo-relative path to absolute filesystem path
	filePath := filepath.Join(repoRoot, strings.TrimPrefix(repoRelativePath, "/"))

	content, err := os.ReadFile(filePath)
	if err != nil {
		// If we can't read the file, fall back to filename
		return filepath.Base(repoRelativePath)
	}

	fileContent := string(content)

	// Try to extract from YAML frontmatter first
	yamlTitleRegex := regexp.MustCompile(`(?m)^title:\s*(.+)$`)
	if matches := yamlTitleRegex.FindStringSubmatch(fileContent); len(matches) > 1 {
		title := strings.TrimSpace(matches[1])

		// Also try to get the ID from frontmatter to create "ID: Title" format
		yamlIDRegex := regexp.MustCompile(`(?m)^id:\s*(.+)$`)
		if idMatches := yamlIDRegex.FindStringSubmatch(fileContent); len(idMatches) > 1 {
			id := strings.TrimSpace(idMatches[1])
			return fmt.Sprintf("%s: %s", id, title)
		}

		return title
	}

	// Fallback: try to extract from H1 heading (# Title)
	h1Regex := regexp.MustCompile(`(?m)^#\s+(.+)$`)
	if matches := h1Regex.FindStringSubmatch(fileContent); len(matches) > 1 {
		return strings.TrimSpace(matches[1])
	}

	// Last resort: use filename
	return filepath.Base(repoRelativePath)
}

// generateBacklinkContent creates the markdown content for the backlinks section
func generateBacklinkContent(targetFilePath string, repoRoot string, backlinks map[parser.DocumentType][]parser.BacklinkInfo) string {
	var sb strings.Builder

	// Add auto-generation note
	sb.WriteString(backlinkAutoGenNote)
	sb.WriteString("\n\n")

	// If no backlinks, indicate that
	if len(backlinks) == 0 {
		sb.WriteString("*No backlinks found.*\n")
		return sb.String()
	}

	// Generate backlinks grouped by type
	// Process in consistent order
	types := []parser.DocumentType{
		parser.TypeControls,
		parser.TypeStandards,
		parser.TypeProcesses,
		parser.TypePolicies,
		parser.TypeCharter,
		parser.TypeFrameworkControl,
	}

	for _, docType := range types {
		backlinksOfType, exists := backlinks[docType]
		if !exists || len(backlinksOfType) == 0 {
			continue
		}

		// Section header for this type
		sb.WriteString(fmt.Sprintf("**%s:**\n", docType))

		// List each backlink
		for _, backlink := range backlinksOfType {
			// Calculate relative path from target file to source file
			relativePath, err := calculateRelativePath(targetFilePath, backlink.SourceFile, repoRoot)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Warning: failed to calculate relative path: %v\n", err)
				continue
			}

			// Extract title from source file for better link text
			linkText := extractTitleFromFile(backlink.SourceFile, repoRoot)

			// Format: - [Link Text](relative/path.md) ^[annotation]
			sb.WriteString(fmt.Sprintf("- [%s](%s) ^[%s]\n",
				linkText,
				relativePath,
				backlink.Annotation))
		}

		sb.WriteString("\n")
	}

	return sb.String()
}

// calculateRelativePath computes the relative path from target to source
// Both paths are repo-relative (e.g., "/custom/acc-01.md", "/standards/aws.md")
func calculateRelativePath(targetFile, sourceFile, repoRoot string) (string, error) {
	// Convert repo-relative paths to absolute filesystem paths
	targetAbs := filepath.Join(repoRoot, strings.TrimPrefix(targetFile, "/"))
	sourceAbs := filepath.Join(repoRoot, strings.TrimPrefix(sourceFile, "/"))

	// Get directory of target file
	targetDir := filepath.Dir(targetAbs)

	// Calculate relative path
	relPath, err := filepath.Rel(targetDir, sourceAbs)
	if err != nil {
		return "", fmt.Errorf("failed to calculate relative path: %w", err)
	}

	// Convert to forward slashes for markdown
	return filepath.ToSlash(relPath), nil
}

// UpdateAllBacklinks updates all files in the backlink graph
func UpdateAllBacklinks(repoRoot string, graph parser.BacklinkGraph) (int, error) {
	updatedCount := 0

	// Get all files that have backlinks
	files := graph.GetFilesWithBacklinks()

	for _, file := range files {
		// Convert repo-relative path to absolute filesystem path
		filePath := filepath.Join(repoRoot, strings.TrimPrefix(file, "/"))

		// Check if file exists
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "Warning: target file %s does not exist, skipping\n", file)
			continue
		}

		// Get backlinks for this file
		backlinks, _ := graph.GetBacklinksForFile(file)

		// Update the file
		err := UpdateBacklinks(filePath, file, repoRoot, backlinks)
		if err != nil {
			// Log error but continue with other files
			fmt.Fprintf(os.Stderr, "Warning: failed to update %s: %v\n", filePath, err)
			continue
		}

		updatedCount++
	}

	return updatedCount, nil
}

// ValidateBacklinkSections checks if files have the required backlink section
func ValidateBacklinkSections(repoRoot string, directories []string) ([]string, error) {
	var missingSection []string

	for _, dir := range directories {
		fullDir := filepath.Join(repoRoot, dir)

		// Check if directory exists
		if _, err := os.Stat(fullDir); os.IsNotExist(err) {
			continue
		}

		// Walk the directory
		err := filepath.Walk(fullDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			// Only process .md files
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".md") {
				// Read file to check for section
				content, err := os.ReadFile(path)
				if err != nil {
					return fmt.Errorf("failed to read %s: %w", path, err)
				}

				if !strings.Contains(string(content), backlinkSectionHeader) {
					// Convert to repo-relative path for reporting
					relPath, _ := filepath.Rel(repoRoot, path)
					missingSection = append(missingSection, relPath)
				}
			}

			return nil
		})

		if err != nil {
			return nil, fmt.Errorf("error walking directory %s: %w", fullDir, err)
		}
	}

	return missingSection, nil
}

// EnsureBacklinkSection adds the backlink section to a file if it doesn't exist
func EnsureBacklinkSection(filePath string) error {
	// Read the file
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	file.Close()

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading file: %w", err)
	}

	content := strings.Join(lines, "\n")

	// Check if section already exists
	if strings.Contains(content, backlinkSectionHeader) {
		return nil // Already has section
	}

	// Add the section at the end
	newContent := content + "\n\n" + backlinkSeparator + "\n\n"
	newContent += "<!-- Backlinks auto-generated below -->\n"
	newContent += backlinkSectionHeader + "\n\n"
	newContent += backlinkAutoGenNote + "\n\n"

	// Write back
	err = os.WriteFile(filePath, []byte(newContent), 0644)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}
